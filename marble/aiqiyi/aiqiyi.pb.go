// Code generated by protoc-gen-go.
// source: aiqiyi.proto
// DO NOT EDIT!

/*
Package aiqiyi is a generated protocol buffer package.

It is generated from these files:
	aiqiyi.proto

It has these top-level messages:
	FloorPrice
	Banner
	Video
	Impression
	Site
	Content
	Device
	Geo
	User
	BidRequest
	Settlement
	Bid
	Seatbid
	BidResponse
*/
package aiqiyi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
// const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FloorPrice struct {
	Industry         *int64 `protobuf:"varint,1,opt,name=industry" json:"industry,omitempty"`
	Price            *int32 `protobuf:"varint,2,opt,name=price" json:"price,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FloorPrice) Reset()                    { *m = FloorPrice{} }
func (m *FloorPrice) String() string            { return proto.CompactTextString(m) }
func (*FloorPrice) ProtoMessage()               {}
func (*FloorPrice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FloorPrice) GetIndustry() int64 {
	if m != nil && m.Industry != nil {
		return *m.Industry
	}
	return 0
}

func (m *FloorPrice) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

type Banner struct {
	// Ad zone identifier.
	AdZoneId *int64 `protobuf:"varint,4,opt,name=ad_zone_id,json=adZoneId" json:"ad_zone_id,omitempty"`
	// This field is always 0 now.
	AdType           *int32 `protobuf:"varint,12,opt,name=ad_type,json=adType" json:"ad_type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Banner) Reset()                    { *m = Banner{} }
func (m *Banner) String() string            { return proto.CompactTextString(m) }
func (*Banner) ProtoMessage()               {}
func (*Banner) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Banner) GetAdZoneId() int64 {
	if m != nil && m.AdZoneId != nil {
		return *m.AdZoneId
	}
	return 0
}

func (m *Banner) GetAdType() int32 {
	if m != nil && m.AdType != nil {
		return *m.AdType
	}
	return 0
}

type Video struct {
	// The iqiyi-internal unique identifier of an ad zone.
	AdZoneId *int64 `protobuf:"varint,1,opt,name=ad_zone_id,json=adZoneId" json:"ad_zone_id,omitempty"`
	// Indicates whether the ad impression is linear or non-linear.
	// 1. Linear, example: pre-roll, mid-roll and post-roll.
	// 2. Non-linear, example: overlay, video link, pause, and tool bar.
	Linearity *int32 `protobuf:"varint,3,opt,name=linearity" json:"linearity,omitempty"`
	// The detail description of the type of an advertisement. The value and
	// corresponding meaning is as following: 1 pre-rool, 2 mid-roll, 3 post-roll,
	// 4 corner, 5 video link, 6 pause, 7 tool bar, 9 overlay.
	AdType *int32 `protobuf:"varint,13,opt,name=ad_type,json=adType" json:"ad_type,omitempty"`
	// The minimum ad duration(in seconds) allowed on this video ad zone.
	Minduration *int32 `protobuf:"varint,4,opt,name=minduration" json:"minduration,omitempty"`
	// The maximum ad duration(in seconds) allowed on this video ad zone.
	Maxduration *int32 `protobuf:"varint,5,opt,name=maxduration" json:"maxduration,omitempty"`
	// Video bid response protocols.
	// 1 VAST 1.0
	// 2 VAST 2.0
	// 3 VAST 3.0
	// 4 VAST 1.0 Wrapper
	// 5 VAST 2.0 Wrapper
	// 6 VAST 3.0 Wrapper
	Protocol *int32 `protobuf:"varint,6,opt,name=protocol" json:"protocol,omitempty"`
	// Width of the player in pixels.
	W *int32 `protobuf:"varint,7,opt,name=w" json:"w,omitempty"`
	// Height of the player in pixels.
	H *int32 `protobuf:"varint,8,opt,name=h" json:"h,omitempty"`
	// A zero-based offset seconds from the start of a roll-type ad. The value
	// of this field is equal to M * 5 + N * 15, M = 0, 1 and N = 0, 1, 2, ...
	Startdelay *int32 `protobuf:"varint,9,opt,name=startdelay" json:"startdelay,omitempty"`
	// This field is meaningful only when this impression is linear. It indicates
	// whether "maxduration" is equal to the total duration this impression holds.
	// That's to say, the entire (pre/mid/post)-roll is available if it is true.
	IsEntireRoll *bool `protobuf:"varint,14,opt,name=is_entire_roll,json=isEntireRoll,def=0" json:"is_entire_roll,omitempty"`
	// A zero-based offset seconds from the start of the video.
	VideoStartdelay  *int32 `protobuf:"varint,15,opt,name=video_startdelay,json=videoStartdelay" json:"video_startdelay,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Video) Reset()                    { *m = Video{} }
func (m *Video) String() string            { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()               {}
func (*Video) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

const Default_Video_IsEntireRoll bool = false

func (m *Video) GetAdZoneId() int64 {
	if m != nil && m.AdZoneId != nil {
		return *m.AdZoneId
	}
	return 0
}

func (m *Video) GetLinearity() int32 {
	if m != nil && m.Linearity != nil {
		return *m.Linearity
	}
	return 0
}

func (m *Video) GetAdType() int32 {
	if m != nil && m.AdType != nil {
		return *m.AdType
	}
	return 0
}

func (m *Video) GetMinduration() int32 {
	if m != nil && m.Minduration != nil {
		return *m.Minduration
	}
	return 0
}

func (m *Video) GetMaxduration() int32 {
	if m != nil && m.Maxduration != nil {
		return *m.Maxduration
	}
	return 0
}

func (m *Video) GetProtocol() int32 {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return 0
}

func (m *Video) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *Video) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

func (m *Video) GetStartdelay() int32 {
	if m != nil && m.Startdelay != nil {
		return *m.Startdelay
	}
	return 0
}

func (m *Video) GetIsEntireRoll() bool {
	if m != nil && m.IsEntireRoll != nil {
		return *m.IsEntireRoll
	}
	return Default_Video_IsEntireRoll
}

func (m *Video) GetVideoStartdelay() int32 {
	if m != nil && m.VideoStartdelay != nil {
		return *m.VideoStartdelay
	}
	return 0
}

type Impression struct {
	// The unique identifier of this impression within the context of the bid
	// request.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// An impression is either banner or video, but not both.
	Banner *Banner `protobuf:"bytes,2,opt,name=banner" json:"banner,omitempty"`
	Video  *Video  `protobuf:"bytes,3,opt,name=video" json:"video,omitempty"`
	// The floor price list of this impression for all industries in
	// RMB(cent per CPM).
	FloorPrice []*FloorPrice `protobuf:"bytes,9,rep,name=floor_price,json=floorPrice" json:"floor_price,omitempty"`
	// Refer to this field to get the floor price if an industry is not found in
	// the "floor_price".
	Bidfloor *int32 `protobuf:"varint,4,opt,name=bidfloor,def=0" json:"bidfloor,omitempty"`
	// Campaign is a facility used by DSP to partition traffic.
	CampaignId *int32 `protobuf:"varint,5,opt,name=campaign_id,json=campaignId" json:"campaign_id,omitempty"`
	// The advertisements with these tags will be blocked on this impression.
	// Ad tag can be understood as the product type in an ad.
	BlockedAdTag       []int32 `protobuf:"varint,6,rep,name=blocked_ad_tag,json=blockedAdTag" json:"blocked_ad_tag,omitempty"`
	BlockedAdAttribute []int32 `protobuf:"varint,7,rep,name=blocked_ad_attribute,json=blockedAdAttribute" json:"blocked_ad_attribute,omitempty"`
	// This impression is a pmp one if this field is set to be true.
	IsPmp            *bool  `protobuf:"varint,8,opt,name=is_pmp,json=isPmp,def=0" json:"is_pmp,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Impression) Reset()                    { *m = Impression{} }
func (m *Impression) String() string            { return proto.CompactTextString(m) }
func (*Impression) ProtoMessage()               {}
func (*Impression) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

const Default_Impression_Bidfloor int32 = 0
const Default_Impression_IsPmp bool = false

func (m *Impression) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Impression) GetBanner() *Banner {
	if m != nil {
		return m.Banner
	}
	return nil
}

func (m *Impression) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *Impression) GetFloorPrice() []*FloorPrice {
	if m != nil {
		return m.FloorPrice
	}
	return nil
}

func (m *Impression) GetBidfloor() int32 {
	if m != nil && m.Bidfloor != nil {
		return *m.Bidfloor
	}
	return Default_Impression_Bidfloor
}

func (m *Impression) GetCampaignId() int32 {
	if m != nil && m.CampaignId != nil {
		return *m.CampaignId
	}
	return 0
}

func (m *Impression) GetBlockedAdTag() []int32 {
	if m != nil {
		return m.BlockedAdTag
	}
	return nil
}

func (m *Impression) GetBlockedAdAttribute() []int32 {
	if m != nil {
		return m.BlockedAdAttribute
	}
	return nil
}

func (m *Impression) GetIsPmp() bool {
	if m != nil && m.IsPmp != nil {
		return *m.IsPmp
	}
	return Default_Impression_IsPmp
}

type Site struct {
	// The iqiyi-internal unique identifier of a site.
	Id               *int32   `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Content          *Content `protobuf:"bytes,11,opt,name=content" json:"content,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Site) Reset()                    { *m = Site{} }
func (m *Site) String() string            { return proto.CompactTextString(m) }
func (*Site) ProtoMessage()               {}
func (*Site) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Site) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Site) GetContent() *Content {
	if m != nil {
		return m.Content
	}
	return nil
}

type Content struct {
	Title *string `protobuf:"bytes,3,opt,name=title" json:"title,omitempty"`
	// Original URL of the content, for buy-side contextualization or review.
	Url *string `protobuf:"bytes,6,opt,name=url" json:"url,omitempty"`
	// The list of keywords describing the content.
	Keyword []string `protobuf:"bytes,9,rep,name=keyword" json:"keyword,omitempty"`
	// The duration of video content in seconds.
	Len *int32 `protobuf:"varint,16,opt,name=len" json:"len,omitempty"`
	// The iqiyi-internal unique identifier of an album.
	AlbumId          *int64 `protobuf:"varint,20,opt,name=album_id,json=albumId" json:"album_id,omitempty"`
	ChannelId        *int64 `protobuf:"varint,22,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Content) Reset()                    { *m = Content{} }
func (m *Content) String() string            { return proto.CompactTextString(m) }
func (*Content) ProtoMessage()               {}
func (*Content) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Content) GetTitle() string {
	if m != nil && m.Title != nil {
		return *m.Title
	}
	return ""
}

func (m *Content) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *Content) GetKeyword() []string {
	if m != nil {
		return m.Keyword
	}
	return nil
}

func (m *Content) GetLen() int32 {
	if m != nil && m.Len != nil {
		return *m.Len
	}
	return 0
}

func (m *Content) GetAlbumId() int64 {
	if m != nil && m.AlbumId != nil {
		return *m.AlbumId
	}
	return 0
}

func (m *Content) GetChannelId() int64 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

type Device struct {
	// Browser user agent string.
	Ua *string `protobuf:"bytes,2,opt,name=ua" json:"ua,omitempty"`
	// IPv4 address closest to device.
	Ip *string `protobuf:"bytes,3,opt,name=ip" json:"ip,omitempty"`
	// Geography information derived from IP address.
	Geo *Geo `protobuf:"bytes,4,opt,name=geo" json:"geo,omitempty"`
	// Return the detected connection type for the device.
	// 0 Unknown
	// 1 Ethernet
	// 2 Wifi
	// 3 Cellular data - 2G
	// 4 Cellular data - 3G
	// 5 Cellular data - 4G
	ConnectionType *int32 `protobuf:"varint,15,opt,name=connection_type,json=connectionType" json:"connection_type,omitempty"`
	// The iqiyi-internal unique identifier of a platform.
	PlatformId *int32 `protobuf:"varint,18,opt,name=platform_id,json=platformId" json:"platform_id,omitempty"`
	// The features supported by the iqiyi ua which the current bid request is
	// from.
	Feature   []int64 `protobuf:"varint,19,rep,name=feature" json:"feature,omitempty"`
	AndroidId *string `protobuf:"bytes,20,opt,name=android_id,json=androidId" json:"android_id,omitempty"`
	// The model for the device.
	// example: iphone, vivoX7
	Model *string `protobuf:"bytes,21,opt,name=model" json:"model,omitempty"`
	// The operating system for the device.
	// example: ios, windows, android
	Os *string `protobuf:"bytes,22,opt,name=os" json:"os,omitempty"`
	// The operating system version for the device.
	// example: 5.1.1
	OsVersion        *string `protobuf:"bytes,23,opt,name=os_version,json=osVersion" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Device) GetUa() string {
	if m != nil && m.Ua != nil {
		return *m.Ua
	}
	return ""
}

func (m *Device) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *Device) GetGeo() *Geo {
	if m != nil {
		return m.Geo
	}
	return nil
}

func (m *Device) GetConnectionType() int32 {
	if m != nil && m.ConnectionType != nil {
		return *m.ConnectionType
	}
	return 0
}

func (m *Device) GetPlatformId() int32 {
	if m != nil && m.PlatformId != nil {
		return *m.PlatformId
	}
	return 0
}

func (m *Device) GetFeature() []int64 {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *Device) GetAndroidId() string {
	if m != nil && m.AndroidId != nil {
		return *m.AndroidId
	}
	return ""
}

func (m *Device) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *Device) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Device) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

type Geo struct {
	Country          *int32 `protobuf:"varint,3,opt,name=country" json:"country,omitempty"`
	Metro            *int32 `protobuf:"varint,5,opt,name=metro" json:"metro,omitempty"`
	City             *int32 `protobuf:"varint,6,opt,name=city" json:"city,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Geo) Reset()                    { *m = Geo{} }
func (m *Geo) String() string            { return proto.CompactTextString(m) }
func (*Geo) ProtoMessage()               {}
func (*Geo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Geo) GetCountry() int32 {
	if m != nil && m.Country != nil {
		return *m.Country
	}
	return 0
}

func (m *Geo) GetMetro() int32 {
	if m != nil && m.Metro != nil {
		return *m.Metro
	}
	return 0
}

func (m *Geo) GetCity() int32 {
	if m != nil && m.City != nil {
		return *m.City
	}
	return 0
}

type User struct {
	// The unique identifier of this user on the exchange.
	// For IOS, this is IDFA or UDID. For Android, this is IMEI or MAC address.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// This field will be set true if the privacy of the current user should be protected.
	IsPrivacyProtected *bool  `protobuf:"varint,2,opt,name=is_privacy_protected,json=isPrivacyProtected,def=0" json:"is_privacy_protected,omitempty"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

const Default_User_IsPrivacyProtected bool = false

func (m *User) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *User) GetIsPrivacyProtected() bool {
	if m != nil && m.IsPrivacyProtected != nil {
		return *m.IsPrivacyProtected
	}
	return Default_User_IsPrivacyProtected
}

type BidRequest struct {
	// Note, the value of this field is not unique.
	Id     *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	User   *User   `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Site   *Site   `protobuf:"bytes,3,opt,name=site" json:"site,omitempty"`
	Device *Device `protobuf:"bytes,5,opt,name=device" json:"device,omitempty"`
	// The list of impression objects. Multiple impression auctions may be
	// specified in a single bid request. At least one impression is required
	// for a valid bid request.
	Imp []*Impression `protobuf:"bytes,8,rep,name=imp" json:"imp,omitempty"`
	// If true, then this is a test request. Results will not be displayed to
	// users and DSP will not be billed for a response even if it wins the
	// auction. DSP should still do regular processing since the request may be
	// used to evaluate latencies or for other testing.
	IsTest *bool `protobuf:"varint,9,opt,name=is_test,json=isTest,def=0" json:"is_test,omitempty"`
	// If true, then this request is intended to measure network latency. Please
	// return an empty BidResponse with only processing_time_ms set as quickly as
	// possible without executing any bidding logic.
	IsPing           *bool  `protobuf:"varint,10,opt,name=is_ping,json=isPing,def=0" json:"is_ping,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BidRequest) Reset()                    { *m = BidRequest{} }
func (m *BidRequest) String() string            { return proto.CompactTextString(m) }
func (*BidRequest) ProtoMessage()               {}
func (*BidRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

const Default_BidRequest_IsTest bool = false
const Default_BidRequest_IsPing bool = false

func (m *BidRequest) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *BidRequest) GetSite() *Site {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *BidRequest) GetDevice() *Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *BidRequest) GetImp() []*Impression {
	if m != nil {
		return m.Imp
	}
	return nil
}

func (m *BidRequest) GetIsTest() bool {
	if m != nil && m.IsTest != nil {
		return *m.IsTest
	}
	return Default_BidRequest_IsTest
}

func (m *BidRequest) GetIsPing() bool {
	if m != nil && m.IsPing != nil {
		return *m.IsPing
	}
	return Default_BidRequest_IsPing
}

// This message will be sent through the impression URL that is specified in the
// VAST XML when an advertisement is displayed to user successfully.
type Settlement struct {
	// This filed can be used to dynamically determine the specific algorithm
	// for generating the fields "price" and "auth". You don't need to care the
	// value of this field until you are told to.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Encrypted price.
	Price []byte `protobuf:"bytes,2,req,name=price" json:"price,omitempty"`
	// Authentication information for "price".
	Auth             []byte `protobuf:"bytes,3,opt,name=auth" json:"auth,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Settlement) Reset()                    { *m = Settlement{} }
func (m *Settlement) String() string            { return proto.CompactTextString(m) }
func (*Settlement) ProtoMessage()               {}
func (*Settlement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Settlement) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Settlement) GetPrice() []byte {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *Settlement) GetAuth() []byte {
	if m != nil {
		return m.Auth
	}
	return nil
}

type Bid struct {
	// ID for the bid object chosen by the bidder for tracking and debugging
	// purposes. It is useful when multiple bids are submitted for a single
	// impression for a given seat.
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// ID of the impression object to which this bid applies.
	Impid *string `protobuf:"bytes,2,req,name=impid" json:"impid,omitempty"`
	// The bidding price in RMB(cent per CPM).
	Price *int32 `protobuf:"varint,3,req,name=price" json:"price,omitempty"`
	// The VAST XML for describing the advertisement of this bid.
	Adm *string `protobuf:"bytes,6,req,name=adm" json:"adm,omitempty"`
	// The id of the creative to be presented to viewers. This field should be
	// populated with the "tvid" that is responded when the creative is uploaded.
	Crid *string `protobuf:"bytes,10,req,name=crid" json:"crid,omitempty"`
	// If the startdelay of an impression object from BidRequest is X, then the
	// valid value of this field is X + N * 15, N = 0, 1, 2, ...
	// Note, if a DSP hopes to have more opportunity to gain an impression, this
	// field should not be set.
	Startdelay *int32 `protobuf:"varint,16,opt,name=startdelay" json:"startdelay,omitempty"`
	// When a bid is returned according to user data such as age, interest,
	// gender and so on, this field should be set to true.
	IsPrecisionAdvertising *bool  `protobuf:"varint,17,opt,name=is_precision_advertising,json=isPrecisionAdvertising,def=0" json:"is_precision_advertising,omitempty"`
	XXX_unrecognized       []byte `json:"-"`
}

func (m *Bid) Reset()                    { *m = Bid{} }
func (m *Bid) String() string            { return proto.CompactTextString(m) }
func (*Bid) ProtoMessage()               {}
func (*Bid) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

const Default_Bid_IsPrecisionAdvertising bool = false

func (m *Bid) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Bid) GetImpid() string {
	if m != nil && m.Impid != nil {
		return *m.Impid
	}
	return ""
}

func (m *Bid) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *Bid) GetAdm() string {
	if m != nil && m.Adm != nil {
		return *m.Adm
	}
	return ""
}

func (m *Bid) GetCrid() string {
	if m != nil && m.Crid != nil {
		return *m.Crid
	}
	return ""
}

func (m *Bid) GetStartdelay() int32 {
	if m != nil && m.Startdelay != nil {
		return *m.Startdelay
	}
	return 0
}

func (m *Bid) GetIsPrecisionAdvertising() bool {
	if m != nil && m.IsPrecisionAdvertising != nil {
		return *m.IsPrecisionAdvertising
	}
	return Default_Bid_IsPrecisionAdvertising
}

type Seatbid struct {
	// The list of bid objects. Each bid object should be related to an impression
	// object in the bid request.
	Bid              []*Bid `protobuf:"bytes,1,rep,name=bid" json:"bid,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Seatbid) Reset()                    { *m = Seatbid{} }
func (m *Seatbid) String() string            { return proto.CompactTextString(m) }
func (*Seatbid) ProtoMessage()               {}
func (*Seatbid) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Seatbid) GetBid() []*Bid {
	if m != nil {
		return m.Bid
	}
	return nil
}

type BidResponse struct {
	// This id should be the same as the id of the corresponding BidRequest.
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// The list of seatbid objects.
	Seatbid []*Seatbid `protobuf:"bytes,2,rep,name=seatbid" json:"seatbid,omitempty"`
	// If BidRequest.is_ping is true, please set this filed with your processing
	// time in milliseconds from receiving request to returning response.
	ProcessingTimeMs *int32 `protobuf:"varint,4,opt,name=processing_time_ms,json=processingTimeMs" json:"processing_time_ms,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BidResponse) Reset()                    { *m = BidResponse{} }
func (m *BidResponse) String() string            { return proto.CompactTextString(m) }
func (*BidResponse) ProtoMessage()               {}
func (*BidResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *BidResponse) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidResponse) GetSeatbid() []*Seatbid {
	if m != nil {
		return m.Seatbid
	}
	return nil
}

func (m *BidResponse) GetProcessingTimeMs() int32 {
	if m != nil && m.ProcessingTimeMs != nil {
		return *m.ProcessingTimeMs
	}
	return 0
}

func init() {
	proto.RegisterType((*FloorPrice)(nil), "aiqiyi.FloorPrice")
	proto.RegisterType((*Banner)(nil), "aiqiyi.Banner")
	proto.RegisterType((*Video)(nil), "aiqiyi.Video")
	proto.RegisterType((*Impression)(nil), "aiqiyi.Impression")
	proto.RegisterType((*Site)(nil), "aiqiyi.Site")
	proto.RegisterType((*Content)(nil), "aiqiyi.Content")
	proto.RegisterType((*Device)(nil), "aiqiyi.Device")
	proto.RegisterType((*Geo)(nil), "aiqiyi.Geo")
	proto.RegisterType((*User)(nil), "aiqiyi.User")
	proto.RegisterType((*BidRequest)(nil), "aiqiyi.BidRequest")
	proto.RegisterType((*Settlement)(nil), "aiqiyi.Settlement")
	proto.RegisterType((*Bid)(nil), "aiqiyi.Bid")
	proto.RegisterType((*Seatbid)(nil), "aiqiyi.Seatbid")
	proto.RegisterType((*BidResponse)(nil), "aiqiyi.BidResponse")
}

// func init() { proto.RegisterFile("aiqiyi.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1093 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x55, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0x86, 0x48, 0x4b, 0x32, 0x47, 0x8a, 0xec, 0xdf, 0xfe, 0xdc, 0x84, 0x2d, 0xf2, 0x47, 0x60,
	0x83, 0x56, 0x41, 0x8b, 0x20, 0x70, 0x0f, 0x05, 0x72, 0x68, 0xe0, 0xf4, 0x4f, 0xa0, 0x43, 0x51,
	0x63, 0xed, 0xe6, 0xd0, 0x0b, 0xb1, 0xe2, 0xae, 0xe5, 0x45, 0x48, 0x2e, 0xb3, 0xbb, 0x72, 0xaa,
	0xbe, 0x44, 0x8f, 0x7d, 0xa5, 0x1e, 0x7b, 0xe8, 0x73, 0xf4, 0x19, 0x8a, 0x99, 0x25, 0x29, 0xd5,
	0xbe, 0xed, 0x7c, 0x33, 0x1c, 0xee, 0xcc, 0xf7, 0xcd, 0x2c, 0x4c, 0x85, 0x7e, 0xaf, 0xb7, 0xfa,
	0x79, 0x63, 0x8d, 0x37, 0x6c, 0x14, 0xac, 0xec, 0x1b, 0x80, 0x1f, 0x4a, 0x63, 0xec, 0xb9, 0xd5,
	0x85, 0x62, 0x9f, 0xc0, 0xa1, 0xae, 0xe5, 0xc6, 0x79, 0xbb, 0x4d, 0x07, 0xf3, 0xc1, 0x22, 0xe6,
	0xbd, 0xcd, 0x4e, 0x60, 0xd8, 0x60, 0x50, 0x1a, 0xcd, 0x07, 0x8b, 0x21, 0x0f, 0x46, 0xf6, 0x0a,
	0x46, 0xaf, 0x45, 0x5d, 0x2b, 0xcb, 0x1e, 0x02, 0x08, 0x99, 0xff, 0x66, 0x6a, 0x95, 0x6b, 0x99,
	0x1e, 0x84, 0xaf, 0x85, 0xfc, 0xc5, 0xd4, 0x6a, 0x29, 0xd9, 0x03, 0x18, 0x0b, 0x99, 0xfb, 0x6d,
	0xa3, 0xd2, 0x29, 0x7d, 0x3f, 0x12, 0xf2, 0x72, 0xdb, 0xa8, 0xec, 0xaf, 0x08, 0x86, 0x6f, 0xb5,
	0x54, 0xe6, 0x56, 0x82, 0xc1, 0xad, 0x04, 0x0f, 0x21, 0x29, 0x75, 0xad, 0x84, 0xd5, 0x7e, 0x9b,
	0xc6, 0x94, 0x62, 0x07, 0xec, 0xa7, 0xbf, 0xb7, 0x9f, 0x9e, 0xcd, 0x61, 0x52, 0x61, 0x09, 0x56,
	0x78, 0x6d, 0x6a, 0xba, 0xd6, 0x90, 0xef, 0x43, 0x14, 0x21, 0x7e, 0xed, 0x23, 0x86, 0x6d, 0xc4,
	0x0e, 0xc2, 0xae, 0x50, 0xd3, 0x0a, 0x53, 0xa6, 0x23, 0x72, 0xf7, 0x36, 0x9b, 0xc2, 0xe0, 0x43,
	0x3a, 0x26, 0x70, 0xf0, 0x01, 0xad, 0xeb, 0xf4, 0x30, 0x58, 0xd7, 0xec, 0x31, 0x80, 0xf3, 0xc2,
	0x7a, 0xa9, 0x4a, 0xb1, 0x4d, 0x13, 0x82, 0xf7, 0x10, 0xf6, 0x05, 0xcc, 0xb4, 0xcb, 0x55, 0xed,
	0xb5, 0x55, 0xb9, 0x35, 0x65, 0x99, 0xce, 0xe6, 0x83, 0xc5, 0xe1, 0xcb, 0xe1, 0x95, 0x28, 0x9d,
	0xe2, 0x53, 0xed, 0xbe, 0x27, 0x1f, 0x37, 0x65, 0xc9, 0x9e, 0xc1, 0xf1, 0x0d, 0xb6, 0x29, 0xdf,
	0x4b, 0x79, 0x44, 0x29, 0x8f, 0x08, 0xbf, 0xe8, 0xe1, 0xec, 0xef, 0x08, 0x60, 0x59, 0x35, 0x56,
	0x39, 0x87, 0xd7, 0x9f, 0x41, 0xd4, 0xf6, 0x33, 0xe1, 0x91, 0x96, 0xec, 0x33, 0x18, 0xad, 0x88,
	0x32, 0x62, 0x72, 0x72, 0x3a, 0x7b, 0xde, 0x2a, 0x23, 0x10, 0xc9, 0x5b, 0x2f, 0xfb, 0x14, 0x86,
	0x94, 0x99, 0xba, 0x3d, 0x39, 0xbd, 0xd7, 0x85, 0x11, 0x5b, 0x3c, 0xf8, 0xd8, 0x57, 0x30, 0xb9,
	0x42, 0xfd, 0xe4, 0x41, 0x1b, 0xc9, 0x3c, 0x5e, 0x4c, 0x4e, 0x59, 0x17, 0xba, 0x93, 0x16, 0x87,
	0xab, 0x9d, 0xcc, 0x1e, 0xc1, 0xe1, 0x4a, 0x4b, 0x02, 0x02, 0x23, 0x2f, 0x07, 0x2f, 0x78, 0x0f,
	0xb1, 0x27, 0x30, 0x29, 0x44, 0xd5, 0x08, 0xbd, 0xae, 0x51, 0x09, 0x81, 0x11, 0xe8, 0xa0, 0xa5,
	0x64, 0x4f, 0x61, 0xb6, 0x2a, 0x4d, 0xf1, 0x4e, 0xc9, 0x1c, 0x59, 0x17, 0xeb, 0x74, 0x34, 0x8f,
	0x17, 0x43, 0x3e, 0x6d, 0xd1, 0x33, 0x79, 0x29, 0xd6, 0xec, 0x05, 0x9c, 0xec, 0x45, 0x09, 0xef,
	0xad, 0x5e, 0x6d, 0xbc, 0x4a, 0xc7, 0x14, 0xcb, 0xfa, 0xd8, 0xb3, 0xce, 0xc3, 0x1e, 0xc2, 0x48,
	0xbb, 0xbc, 0xa9, 0x1a, 0xe2, 0xb0, 0x27, 0x62, 0xa8, 0xdd, 0x79, 0xd5, 0x64, 0x67, 0x70, 0x70,
	0xa1, 0xbd, 0xda, 0xeb, 0xe7, 0x90, 0xfa, 0xf9, 0x0c, 0xc6, 0x85, 0xa9, 0xbd, 0xaa, 0x7d, 0x3a,
	0xa1, 0x4e, 0x1d, 0x75, 0xe5, 0x7f, 0x1b, 0x60, 0xde, 0xf9, 0xb3, 0x3f, 0x06, 0x30, 0x6e, 0x41,
	0x9c, 0x27, 0xaf, 0x7d, 0xa9, 0xa8, 0xbd, 0x09, 0x0f, 0x06, 0x3b, 0x86, 0x78, 0x63, 0x83, 0xcc,
	0x12, 0x8e, 0x47, 0x96, 0xc2, 0xf8, 0x9d, 0xda, 0x7e, 0x30, 0x56, 0x52, 0x77, 0x13, 0xde, 0x99,
	0x18, 0x5b, 0xaa, 0x3a, 0x3d, 0xa6, 0x9b, 0xe0, 0x91, 0x7d, 0x0c, 0x87, 0xa2, 0x5c, 0x6d, 0x2a,
	0x6c, 0xdb, 0x09, 0x0d, 0xd0, 0x98, 0xec, 0xa5, 0x64, 0x8f, 0x00, 0x8a, 0x6b, 0x24, 0xb6, 0x44,
	0xe7, 0x7d, 0x72, 0x26, 0x2d, 0xb2, 0x94, 0xd9, 0xef, 0x11, 0x8c, 0xbe, 0x53, 0x37, 0xc8, 0xce,
	0x0c, 0xa2, 0x8d, 0x20, 0x6d, 0x24, 0x3c, 0xda, 0x08, 0xaa, 0xb7, 0x69, 0x6f, 0x19, 0xe9, 0x86,
	0x3d, 0x82, 0x78, 0xad, 0x0c, 0x11, 0x37, 0x39, 0x9d, 0x74, 0xb5, 0xbe, 0x51, 0x86, 0x23, 0xce,
	0x3e, 0x87, 0xa3, 0xc2, 0xd4, 0xb5, 0x2a, 0x70, 0x76, 0xc2, 0x48, 0x06, 0x9d, 0xce, 0x76, 0x30,
	0x8d, 0xe6, 0x13, 0x98, 0x34, 0xa5, 0xf0, 0x57, 0xc6, 0xd2, 0x7d, 0x59, 0xa0, 0xb9, 0x83, 0x96,
	0x12, 0x2b, 0xbf, 0x52, 0xc2, 0x6f, 0xac, 0x4a, 0xff, 0x3f, 0x8f, 0xb1, 0x98, 0xd6, 0xc4, 0x62,
	0x44, 0x2d, 0xad, 0xd1, 0xb2, 0xab, 0x34, 0xe1, 0x49, 0x8b, 0x2c, 0x25, 0xb6, 0xb6, 0x32, 0x52,
	0x95, 0xe9, 0x47, 0xa1, 0xb5, 0x64, 0x60, 0x1d, 0xc6, 0x51, 0xe5, 0x09, 0x8f, 0x8c, 0xc3, 0x24,
	0xc6, 0xe5, 0x37, 0xca, 0xe2, 0x94, 0xa4, 0x0f, 0x42, 0x12, 0xe3, 0xde, 0x06, 0x20, 0x5b, 0x42,
	0xfc, 0x46, 0x19, 0xbc, 0x44, 0x61, 0x36, 0x35, 0x6e, 0xc4, 0xb0, 0x75, 0x3a, 0x93, 0xfe, 0xa2,
	0xbc, 0x35, 0xad, 0x40, 0x83, 0xc1, 0x18, 0x1c, 0x14, 0xb8, 0xa2, 0xc2, 0xa2, 0xa0, 0x73, 0xf6,
	0x13, 0x1c, 0xfc, 0xec, 0x94, 0xbd, 0x33, 0x89, 0x5f, 0xc3, 0x09, 0xea, 0xcd, 0xea, 0x1b, 0x51,
	0x6c, 0x73, 0xdc, 0x29, 0xaa, 0xf0, 0x4a, 0x52, 0xef, 0x7b, 0xf5, 0x31, 0xed, 0xce, 0x43, 0xc4,
	0x79, 0x17, 0x90, 0xfd, 0x33, 0x00, 0x78, 0xad, 0x25, 0x57, 0xef, 0x37, 0xca, 0xf9, 0x3b, 0x79,
	0xe7, 0x70, 0xb0, 0x71, 0xfd, 0x7c, 0x4f, 0x3b, 0x8a, 0xf0, 0x0e, 0x9c, 0x3c, 0x18, 0xe1, 0xb4,
	0x57, 0xed, 0x68, 0xf7, 0x11, 0xa8, 0x6f, 0x4e, 0x1e, 0xdc, 0x12, 0x92, 0xf4, 0x40, 0xe5, 0xed,
	0x6d, 0x89, 0xa0, 0x12, 0xde, 0x7a, 0xd9, 0x53, 0x88, 0x35, 0x0d, 0xcc, 0x7f, 0x06, 0x7f, 0xb7,
	0x7e, 0x38, 0xba, 0xd9, 0x63, 0x18, 0x6b, 0x97, 0x7b, 0xe5, 0x3c, 0xed, 0xc1, 0xbe, 0xb8, 0x91,
	0x76, 0x97, 0x58, 0x41, 0xf0, 0x37, 0xba, 0x5e, 0xa7, 0x70, 0xcb, 0x7f, 0xae, 0xeb, 0x75, 0x76,
	0x0e, 0x70, 0xa1, 0xbc, 0x2f, 0x55, 0x85, 0xa3, 0x93, 0xc2, 0xb8, 0xa3, 0x0d, 0x8b, 0xbe, 0xc7,
	0x3b, 0x73, 0xff, 0x91, 0x8a, 0x16, 0xd3, 0xf6, 0x91, 0x42, 0x4e, 0xc4, 0xc6, 0x5f, 0x53, 0xb5,
	0x53, 0x4e, 0xe7, 0xec, 0xcf, 0x01, 0xc4, 0xaf, 0xb5, 0xec, 0x7b, 0x17, 0xb5, 0xbd, 0x3b, 0x81,
	0xa1, 0xae, 0x1a, 0x2d, 0x29, 0x43, 0xc2, 0x83, 0xb1, 0xcb, 0x1b, 0xcf, 0xa3, 0xfe, 0xf1, 0xc3,
	0x01, 0x14, 0xb2, 0x4a, 0x47, 0x14, 0x89, 0x47, 0x62, 0xdf, 0x6a, 0x99, 0x02, 0x41, 0x74, 0xbe,
	0xf5, 0x0c, 0x1c, 0xdf, 0x79, 0x06, 0x5e, 0x41, 0x4a, 0x2a, 0x50, 0x85, 0xc6, 0x1a, 0x72, 0x21,
	0x6f, 0x94, 0xf5, 0xda, 0x61, 0x33, 0xfe, 0xb7, 0xdf, 0x8c, 0xfb, 0xa8, 0x84, 0x36, 0xea, 0x6c,
	0x17, 0x94, 0x2d, 0x60, 0x7c, 0xa1, 0x84, 0x5f, 0x69, 0x9c, 0xf2, 0x78, 0x45, 0xe5, 0xc4, 0xfb,
	0xb3, 0x89, 0x52, 0x41, 0x3c, 0xbb, 0x81, 0x09, 0xc9, 0xc6, 0x35, 0xa6, 0x76, 0xea, 0x4e, 0xed,
	0xcf, 0x60, 0xec, 0x42, 0xa2, 0x34, 0xa2, 0x0c, 0xfd, 0x26, 0x6b, 0xf3, 0xf3, 0xce, 0xcf, 0xbe,
	0x04, 0xd6, 0x58, 0x53, 0x20, 0xc7, 0xf5, 0x3a, 0xf7, 0xba, 0x52, 0x79, 0xe5, 0xda, 0xe7, 0xf5,
	0x78, 0xe7, 0xb9, 0xd4, 0x95, 0xfa, 0xd1, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xef, 0x1a, 0x1e,
	0xbe, 0x7c, 0x08, 0x00, 0x00,
}
